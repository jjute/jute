package io.jjute.plugin.testsuite.file;

import org.jetbrains.annotations.TestOnly;

/**
 * This object represents a DSL <i>(Gradle build language)</i> {@link BuildFile} textual entry.
 * <p>
 *     Each entry should be considered with intent to be written to a {@code BuildFile} being tested by
 *     {@link io.jjute.plugin.testsuite.core.PluginTest PluginTest}. An expression can either be a plain
 *     statement with one or more text lines or a script block which is a method call which takes a closure
 *     as a parameter. The closure is treated as a configuration closure which configures some delegate
 *     object as it executes. Note that a build script is also a Groovy script, and so can contain
 *     those elements allowed in a Groovy script, such as method definitions and class definitions.
 * </p>
 * @see <a href="https://docs.gradle.org/current/dsl/index.html#N10060">
 *      Gradle Docs: Build script structure</a>
 */
@TestOnly
class TextEntry {

    /**
     * List of {@code String} values that represent {@code BuildFile} line entries.
     * List entries are expected to be sorted according to natural order as they are
     * intended to appear in the text file.
     * <p>
     *     Note that this is an <b>immutable</b> {@code List} and any attempts to
     *     modify the list, whether direct or via its iterator, result in an
     *     {@code UnsupportedOperationException} exception.
     * </p>
     */
    final java.util.List<String> lines;

    private TextEntry(String[] lines) {
        this.lines = java.util.Collections.unmodifiableList(java.util.Arrays.asList(lines));
    }

    /**
     * Custom {@code LinkedHashMap} implementation that maps {@code TextEntry} objects to unique
     * names or {@code String} based identifiers. This class has the sole responsibility of creating,
     * storing and retrieving {@code TextEntry} instances and there should be no need to handle them
     * directly outside this class with the exception of writing to {@code BuildFile}.
     */
     static class Map extends java.util.LinkedHashMap<String, TextEntry> {

        /**
         * Used to generate {@code Map} entry identifiers.
         * @see #storeInternal(EntryType, TextEntry)
         */
        enum EntryType { SINGLE, BLOCK }

        /**
         * Used to generate the <b>next</b> {@code Map} entry identifier.
         * @see #storeInternal(EntryType, TextEntry)
         */
        private int nextEntryId = 1;

        /**
         * Create a new {@code TextEntry} with the given {@code String} array and
         * associate it with the specified {@code name}. If the map previously
         * contained a mapping for the given name, the old value is replaced.
         *
         * @param name {@code Map} key to associate with.
         * @param lines {@code BuildFile} line entries.
         */
        void put(String name, String[] lines) {

            if (name.isEmpty() || lines.length == 0) {
                throw new IllegalArgumentException(String.format("Invalid TextEntry parameters "
                        + " name: %s, lines: %s", name, java.util.Arrays.toString(lines)));
            }
            else put(name, new TextEntry(lines));
        }

        /**
         * Create a new {@code TextEntry} with the given {@code String} that represents a
         * DSL statement and associate it with a <i>unique</i> {@link EntryType#SINGLE
         * EntryType.SINGLE} identifier generated by an internal class method.
         *
         * @param line single {@code BuildFile} line entry.
         */
        void put(String line) {

            if (line.isEmpty()) {
                throw new IllegalArgumentException("Invalid TextEntry parameter: empty string.");
            }
            storeInternal(EntryType.SINGLE, new TextEntry(new String[]{line}));
        }

        /**
         * Create a new {@code TextEntry} with the given {@code String} array that represents
         * a DSL script block and associate it with a <i>unique</i> {@link EntryType#SINGLE
         * EntryType.BLOCK} identifier generated by an internal class method.
         *
         * @param lines {@code BuildFile} line entries.
         */
        void put(String[] lines) {

            if (lines.length == 0) {
                throw new IllegalArgumentException("Invalid TextEntry parameter: empty array.");
            }
            storeInternal(EntryType.BLOCK, new TextEntry(lines));
        }

        /**
         * Compose and return a {@code List} of {@code TextEntry} string lines contained in this map
         * while maintaining natural insertion order, which means that the order of list elements
         * will be determined by map entry and that entry's list insertion order. The same way
         * entries were created and inserted is the way they will be displayed in return value.
         */
        java.util.List<String> getTextLines() {

            java.util.List<String> textLines = new java.util.ArrayList<>();
            values().forEach(entry -> textLines.addAll(entry.lines));
            return textLines;
        }

        private void storeInternal(EntryType type, TextEntry entry) {
            put(String.valueOf(type.ordinal()) + ':' + nextEntryId++, entry);
        }
    }
}
