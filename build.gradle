import org.apache.commons.io.FileUtils

buildscript {
    repositories.jcenter()
    dependencies.classpath 'commons-io:commons-io:2.6'
}

plugins {
    id 'java-gradle-plugin'
    id 'groovy'
    id 'idea'
}
/*
 * Custom test task configurations:
 *
 * - Clean test temporary files.
 * - Enable Gradle JUnit integration.
 * - Track test progress through console logging.
 * - Improve exception logging format.
 */
apply from: 'testsuite.gradle'

gradlePlugin {
    plugins {
        jutePlugin.id = 'io.jjute.integration-framework'
        jutePlugin.implementationClass = 'io.jjute.plugin.framework.JutePlugin'
    }
}

group = 'io.yooksi.jute'

/*
 * Set source and target compatibility for compiling Java sources.
 * This will also define the Language Level that corresponds to the given Java version.
 */
setSourceCompatibility(JavaVersion.VERSION_1_8)
setTargetCompatibility(JavaVersion.VERSION_1_8)

/*
 * Sets the build directory of this project.
 * The build directory is the directory which all artifacts are generated into.
 */
buildDir = projectDir.toPath().resolve("build").toFile()

/*
 * Define custom dependency configurations here
 */
configurations {
    /*
     * Implementation dependencies that should be shared by all source sets.
     * This should encompass common use and utility dependencies such as Apache libraries.
     */
    sharedImplementation.extendsFrom implementation
    /*
     * Test implementation dependencies used by testsuite and test sources.
     */
    testFixture.extendsFrom testImplementation
}

sourceSets {
    main {
        /* The Groovy plugin extends the Java plugin and compiles Groovy along with Java.
         * What we are doing here is telling Groovy to compile everything for us, so there is
         * no need to compile Java code twice. In fact setting Java srcDirs here would throw errors.
         * https://stackoverflow.com/questions/22369033/how-to-use-gradle-java-and-groovy-together
         */
        java.srcDirs = []
        groovy.srcDirs = ["src/main/java", "src/main/groovy"]
    }
    testsuite {
        groovy.srcDirs = ['src/testsuite/java']
        compileClasspath = sourceSets.main.output + configurations.testFixture
    }
    test {
        groovy.srcDirs = ['src/test/java']
        compileClasspath = sourceSets.testsuite.output + sourceSets.main.output + configurations.testRuntime
    }
    testInt {
        groovy.srcDirs = ['src/testInt/java']
        compileClasspath = sourceSets.test.compileClasspath
    }
}
/*
 * Add shared implementation dependencies to both compile and runtime classpath.
 * It's important to add them to runtime classpath so we can run tests through Gradle.
 */
sourceSets.each { set ->
    set.compileClasspath += configurations.sharedImplementation
    set.runtimeClasspath += set.output + set.compileClasspath + configurations.sharedImplementation
}

idea {
    module {
        /*
         * The JDK to use for this module. If null, the value of the existing or default
         * ipr XML (inherited) is used. If it is set to inherited, the project SDK is used.
         * Otherwise the SDK for the corresponding value of java version is used for this module.
         */
        jdkName = '1.8'

        /*
         * If true, output directories for this module will be located below
         * the output directory for the project otherwise, they will be set to
         * the directories specified by getter method return values.
         */
        inheritOutputDirs = false

        outputDir file('build/target/production')
        testOutputDir file('build/target/test')

        setTargetBytecodeVersion(JavaVersion.VERSION_1_8)

        /*
         * Add integration test sources to project test sources.
         * This will make sure module directories are properly marked as tests
         */
        testSourceDirs += project.sourceSets.testInt.java.srcDirs
    }
}

repositories.jcenter()

dependencies {

    // The Gradle TestKit (a.k.a. just TestKit) is a library that aids in testing Gradle
    // plugins and build logic generally. At this time, it is focused on functional testing.
    // https://docs.gradle.org/current/userguide/test_kit.html
    testFixture gradleTestKit()

    // This dependency allows us to write tests and extensions which use JUnit 5
    // https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api
    testFixture 'org.junit.jupiter:junit-jupiter-api:5.5.0'

    // This dependency allows us to run tests which use JUnit 5
    // https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine
    testRuntime 'org.junit.jupiter:junit-jupiter-engine:5.5.0'

    // https://mvnrepository.com/artifact/org.apache.commons/commons-lang3
    sharedImplementation 'org.apache.commons:commons-lang3:3.9'

    // https://mvnrepository.com/artifact/commons-io/commons-io
    sharedImplementation 'commons-io:commons-io:2.6'

    // JetBrains Java Annotations
    // https://mvnrepository.com/artifact/org.jetbrains/annotations
    sharedImplementation 'org.jetbrains:annotations:17.0.0'

    // https://mvnrepository.com/artifact/javax.validation/validation-api
    sharedImplementation 'javax.validation:validation-api:2.0.1.Final'
}
/*
 * Plugin development tasks should be called before running
 * integration tests to make sure plugin metadata is up-to-date
 */
task updatePluginMetadata {
    group 'plugin development'
    description 'Update plugin descriptors and generate metadata for functional tests.'
    dependsOn = ['pluginDescriptors', 'pluginUnderTestMetadata']
}
/*
 * Modify this task to recursively delete all IntelliJ IDEA test output files.
 * This should be called before running defined IDEA test configurations.
 */
tasks.register('cleanIdeaTest') {

    File ideaTestOutputDir = file('build/target/')
    onlyIf { ideaTestOutputDir.exists() }
    doLast {
        FileUtils.deleteDirectory(ideaTestOutputDir)
        logger.debug("Cleaned IDEA test output directory.")
    }
}
tasks.register('configIdeaIntTests') { 
    dependsOn = ['cleanTest', 'assemble', 'updatePluginMetadata'] 
cleanTest.dependsOn cleanIdeaTest
}
