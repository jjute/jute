import org.apache.commons.io.FileUtils
import org.gradle.plugins.ide.idea.model.IdeaModule
import java.nio.file.Paths

buildscript {
    repositories.jcenter()
    dependencies.classpath 'commons-io:commons-io:2.6'
}

plugins {
    id 'java-gradle-plugin'
    id 'idea'
}
/*
 * Custom test task configurations:
 *
 * - Clean test temporary files.
 * - Enable Gradle JUnit integration.
 * - Track test progress through console logging.
 * - Improve exception logging format.
 */
apply from: 'testsuite.gradle'

gradlePlugin {
    plugins {
        jutePlugin.id = 'io.jjute.integration-framework'
        jutePlugin.implementationClass = 'io.jjute.plugin.framework.JutePlugin'
    }
}

/*
 * Set source and target compatibility for compiling Java sources.
 * This will also define the Language Level that corresponds to the given Java version.
 */
setSourceCompatibility(JavaVersion.VERSION_1_8)
setTargetCompatibility(JavaVersion.VERSION_1_8)

/*
 * Sets the build directory of this project.
 * The build directory is the directory which all artifacts are generated into.
 */
buildDir = projectDir.toPath().resolve("build").toFile()

/*
 * Define custom dependency configurations here
 */
configurations {
    /*
     * Implementation dependencies that should be shared by all source sets.
     * This should encompass common use and utility dependencies such as Apache libraries.
     */
    sharedImplementation.extendsFrom implementation
}

sourceSets {
    testInt {
        java.srcDirs = ['src/testInt/java']
        compileClasspath = sourceSets.main.output + configurations.testRuntime
        runtimeClasspath = output + compileClasspath
    }
    test {
        java.srcDirs = ['src/test/java']
        compileClasspath = sourceSets.main.output + configurations.testRuntime
        runtimeClasspath = output + compileClasspath
    }
    main.compileClasspath += configurations.testCompile
}
/*
 * Add shared implementation dependencies to both compile and runtime classpath.
 * It's important to add them to runtime classpath so we can run tests through Gradle.
 */
sourceSets.each { set ->
    set.compileClasspath += configurations.sharedImplementation
    set.runtimeClasspath += configurations.sharedImplementation
}

idea {
    module {
        /*
         * The JDK to use for this module. If null, the value of the existing or default
         * ipr XML (inherited) is used. If it is set to inherited, the project SDK is used.
         * Otherwise the SDK for the corresponding value of java version is used for this module.
         */
        jdkName = '1.8'

        /*
         * If true, output directories for this module will be located below
         * the output directory for the project otherwise, they will be set to
         * the directories specified by getter method return values.
         */
        inheritOutputDirs = false

        outputDir file('build/target/production')
        testOutputDir file('build/target/test')

        setTargetBytecodeVersion(JavaVersion.VERSION_1_8)

        /*
         * Add integration test sources to project test sources.
         * This will make sure module directories are properly marked as tests
         */
        sourceDirs -= file('src/testInt/java')
        testSourceDirs += file('src/testInt/java')
    }
}

repositories.jcenter()

dependencies {

    // This dependency allows us to write tests and extensions which use JUnit 5
    // https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.5.0'

    // This dependency allows us to run tests which use JUnit 5
    // https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine
    testRuntime 'org.junit.jupiter:junit-jupiter-engine:5.5.0'
    
    testCompile gradleTestKit()

    // https://mvnrepository.com/artifact/org.apache.commons/commons-lang3
    sharedImplementation 'org.apache.commons:commons-lang3:3.9'

    // https://mvnrepository.com/artifact/commons-io/commons-io
    sharedImplementation 'commons-io:commons-io:2.6'

    // JetBrains Java Annotations
    // https://mvnrepository.com/artifact/org.jetbrains/annotations
    sharedImplementation 'org.jetbrains:annotations:17.0.0'

    // https://mvnrepository.com/artifact/javax.validation/validation-api
    sharedImplementation 'javax.validation:validation-api:2.0.1.Final'
}
/*
 * Plugin development tasks should be called before running
 * integration tests to make sure plugin metadata is up-to-date
 */
task updatePluginMetadata {
    group 'plugin development'
    description 'Update plugin descriptors and generate metadata for functional tests.'
    dependsOn = ['pluginDescriptors', 'pluginUnderTestMetadata']
}
/*
 * Modify this task to recursively delete all IntelliJ IDEA test output files.
 * This should be called before running defined IDEA test configurations.
 */
cleanTest {
    File ideaTestOutputDir = file('build/target/')
    onlyIf { ideaTestOutputDir.exists() }
    doLast {
        FileUtils.deleteDirectory(ideaTestOutputDir)
        logger.debug("Cleaned IDEA test output directory.")
    }
}

/*
 * Configures this project AND each of its sub-projects.
 */
allprojects {
    // Every sub-project should belong to this group
    group = 'io.yooksi.jute'
}
/*
 * Configures ONLY the sub-projects of this project.
 */
subprojects {
    apply from: resolveRootPath(initScriptPath)
}

/**
 * Resolve the given path against the root project's directory path.
 */
def resolveRootPath(String pathToResolve) {
    return Paths.get(rootDir.path, pathToResolve).toString()
}

/*
 * This variable will be initialized to true if the current
 * operating system platform is Windows and false otherwise
 */
ext.isOsWindows = System.getProperty("os.name").startsWith("Windows")

/**
 * Run a <i>platform-independent</i> shell command.
 */
void runShellCommand(String... arguments) {

    def stdout = new ByteArrayOutputStream()
    String[] command = new String[arguments.length + 2]

    if (project.isOsWindows) {
        command[0] = 'cmd'; command[1] = '/c'
    }
    else { command[0] = 'sh'; command[1] = '-c' }
    System.arraycopy(arguments, 0, command, 2, arguments.length)

    exec {  commandLine command }
    println stdout.toString().trim()
}

/**
 * Execute a Git command with the given arguments.
 * The output will be printed to console
 */
void runGitCommand(String... args) {

    def stdout = new ByteArrayOutputStream()
    String[] cmdArgs = new String[args.length + 1]
    
    cmdArgs[0] = 'git'
    System.arraycopy(args, 0, cmdArgs, 1, args.length)
    
    exec { commandLine cmdArgs }
    println stdout.toString().trim()
}

/**
 * Download a text-based file from a given URL and store it in the given directory.
 *
 * @param url location of the file on the web
 * @param dir directory file used to store the target file
 *
 * @throws MalformedURLException if the parsed URL failed to comply with the
 *                               specific syntax of the associated protocol.
 *
 * @throws FileNotFoundException if the given file is not a valid directory.
 *
 * @throws IllegalStateException if the target directory does not exist and we were
 *                               unable to create the missing directory structure
 */
void downloadFileFromWeb(String url, File dir) {

    logger.info("Downloading file: $url\nDestination dir: " + dir.path)

    if (dir.exists()) {
        if (!dir.isDirectory())
            throw new FileNotFoundException("Target path is not a valid directory!")
    }
    else if (!dir.mkdirs()) {
        throw new IllegalStateException("Unable to create directory structure for path: " + dir.path)
    }
    final URL location = new URL(url)
    File target = dir.toPath().resolve(location.getFile()).toFile()
    target.createNewFile(); target << location.getText()
}

/**
 * @return <code>true</code> if any of the submodules listed in <code>juteModules</code>
 * property do not exists in the designated modules directory. Submodule state of existence
 * is evaluated by the existence of '.git' file inside the module root directory.
 */
boolean isAnySubmoduleMissing() {

    boolean needsUpdate = false
    gradle.juteModules.each { module ->
        needsUpdate = !getModuleGitDir(module).exists()
    }
    return needsUpdate
}
/**
 * @return the <code>Path</code> to the given module root directory
 */
@SuppressWarnings("GrMethodMayBeStatic")
java.nio.file.Path getModuleDir(String module) {
    return Paths.get(juteModulesPath).resolve(module)
}
/**
 * Resolve the given path against the module root directory path.
 * @return <code>String</code> representation of the <code>Path</code>
 */
String resolveModulePath(String module, String path) {
    return getModuleDir(module).resolve(path).toString()
}
/**
 * @return the Git metadata <code>File</code> (.git) for the given module. 
 */
File getModuleGitDir(String module) {
    return file(resolveModulePath(module, '.git'))
}
/*
 * See 'initModules' task for more info 
 */
private void cloneAndInitModule(String module) {

    String url = "https://github.com/jjute/$module"
    String path = getModuleDir(module)
    String branch = 'develop'

    final File moduleDir = file(path)
    if (moduleDir.exists())
    {
        if (!getModuleGitDir(module).exists()) {
//            FileUtils.deleteDirectory(moduleDir)
        }
        else return
    }
    runGitCommand('clone', '--branch', branch, url, path)
}

/*
 * Clone and initialize all missing project modules.
 * The module names are listed in juteModuleNames property
 */
tasks.register('initModules') {
    group = 'module'
    description = 'Clone and initialize missing project modules.'
    onlyIf {
        isAnySubmoduleMissing()
    }
    doLast {
        logger.quiet("Cloning and initializing Jute modules...")
        gradle.juteModules.each { module -> cloneAndInitModule(module) }
    }
}

/*
 * List all Jute modules currently residing in the ./modules directory.
 */
tasks.register('listModules') {
    group = 'module'
    description = 'List all registered Jute modules.'
    doFirst {
        logger.quiet("List of registered Jute modules:")
    }
    doLast {
        rootProject.subprojects.each {
            logger.quiet("- $it.name")
        }
    }
}

tasks.register('getSourceSetInfo') {

    group 'verification'
    description 'Print directory paths for each source set.'

    sourceSets.findAll { srcSet ->
        List<File> srcSetList = srcSet.java.srcDirs.asList()
        logger.quiet(String.format("Printing %s source set content(%d):", srcSet.name, srcSetList.size()))
        logger.quiet("Directories: " + Arrays.toString(srcSetList.toArray(new File[0])))
    }
}