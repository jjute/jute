import java.nio.file.Paths

/*
 * Configures this project AND each of its sub-projects.
 */
allprojects {
    // Every sub-project should belong to this group
    group = 'io.yooksi.jute'
}
/*
 * Configures ONLY the sub-projects of this project.
 */
subprojects {
    apply from: resolveRootPath(initScriptPath)
    if (codeCoverageEnabled.equals('true'))
        apply from: resolveRootPath(coverageScriptPath)
}
/**
 * Resolve the given path against the root project's directory path.
 */
def resolveRootPath(String pathToResolve) {
    return Paths.get(rootDir.path, pathToResolve).toString()
}

/*
 * This variable will be initialized to true if the current
 * operating system platform is Windows and false otherwise
 */
ext.isOsWindows = System.getProperty("os.name").startsWith("Windows")

/**
 * Run a <i>platform-independent</i> shell command.
 */
void runShellCommand(String... arguments) {

    def stdout = new ByteArrayOutputStream()
    String[] command = new String[arguments.length + 2]

    if (project.isOsWindows) {
        command[0] = 'cmd'; command[1] = '/c'
    }
    else { command[0] = 'sh'; command[1] = '-c' }
    System.arraycopy(arguments, 0, command, 2, arguments.length)

    exec {  commandLine command }
    println stdout.toString().trim()
}

/**
 * Execute a Git command with the given arguments.
 * The output will be printed to console
 */
void runGitCommand(String... args) {

    def stdout = new ByteArrayOutputStream()
    String[] cmdArgs = new String[args.length + 1]
    
    cmdArgs[0] = 'git'
    System.arraycopy(args, 0, cmdArgs, 1, args.length)
    
    exec { commandLine cmdArgs }
    println stdout.toString().trim()
}

/**
 * Download a text-based file from a given URL and store it in the given directory.
 *
 * @param url location of the file on the web
 * @param dir directory file used to store the target file
 *
 * @throws MalformedURLException if the parsed URL failed to comply with the
 *                               specific syntax of the associated protocol.
 *
 * @throws FileNotFoundException if the given file is not a valid directory.
 *
 * @throws IllegalStateException if the target directory does not exist and we were
 *                               unable to create the missing directory structure
 */
void downloadFileFromWeb(String url, File dir) {

    logger.info("Downloading file: $url\nDestination dir: " + dir.path)

    if (dir.exists()) {
        if (!dir.isDirectory())
            throw new FileNotFoundException("Target path is not a valid directory!")
    }
    else if (!dir.mkdirs()) {
        throw new IllegalStateException("Unable to create directory structure for path: " + dir.path)
    }
    final URL location = new URL(url)
    String filename = file(location.getPath()).getName()
    File target = dir.toPath().resolve(filename).toFile()
    target.createNewFile(); target << location.getText()
}

/**
 * @return <code>true</code> if any of the submodules listed in <code>juteModules</code>
 * property do not exists in the designated modules directory. Submodule state of existence
 * is evaluated by the existence of '.git' file inside the module root directory.
 */
boolean isAnySubmoduleMissing() {

    boolean needsUpdate = false
    gradle.juteModules.each { module ->
        needsUpdate = !file("./modules/$module/.git").exists()
    }
    return needsUpdate
}

/*
 * Clone and initialize all remote submodules to the local modules directory.
 * TODO: Option to initialize only specified modules
 */
tasks.register('initModules') {
    group = 'module'
    description = 'Clone remote modules from Github'
    onlyIf {
        isAnySubmoduleMissing()
    }
    doLast {
        logger.quiet("Initializing git submodules...")

        // Clone and initialize all submodules
        runGitCommand('submodule', 'update', '--init', './modules')

        // Apply project git configuration for repository
        runGitCommand('config', '--local', 'include.path', '../.gitconfig')

        // Switch to develop branch for each module
        gradle.juteModules.each { module ->
            runShellCommand("cd modules/$module && git checkout develop")
        }
    }
}

/*
 * List all Jute modules currently residing in the ./modules directory.
 */
tasks.register('listModules') {
    group = 'module'
    description = 'List all registered Jute modules.'
    doFirst {
        logger.quiet("List of registered Jute modules:")
    }
    doLast {
        rootProject.subprojects.each {
            logger.quiet("- $it.name")
        }
    }
}
